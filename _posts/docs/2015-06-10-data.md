---
layout: post
title:  Data Preparation
category : docs
tags : [data]
---
{% include JB/setup %}

To submit a training job, users need to convert raw data (e.g., images, text
documents) into records that can be recognized by SINGA. SINGA uses data layers
to load these records into memory and uses parser layers to parse features (e.g.,
image pixels and labels) from these records. The records could be organized and
stored using many different ways, e.g., a file, a light database, or HDFS, as
long as there is a corresponding [DataLayer]({{ BASE_PATH }}/api/classsinga_1_1DataLayer.html) that can load the records.

## DataShard

SINGA comes with a light database named [DataShard]({{ BASE_PATH }}/api/classsinga_1_1DataShard.html).
It provides operations for inserting `Record`, and read `Record` in sequential order.
The `Record`s are flushed once the maximum cache size is reached. Similarly, it
reads `Records` in batch and returns one by one to users. The disk file is called
a (data) shard.

To create shard for users' own data, they can follow the subsequent steps.

### User record definition

Users define their own record for storing their data. E.g., the built-in
[SingleLabelImageRecord]({{ BASE_PATH }}/api/classsinga_1_1SingleLabelImageRecord.html)
has an int field for image label, and a pixel array for image RGB values.
The user record can be defined using [protocol buffer message](api/classsinga_1_1SingleLabelImageRecord.html) like,

    message UserRecord1 {
        repeated int userVAR1 = 1;    // unique field id
        optional string userVAR2 = 2; // unique field id
        ...
    }
    message UserRecord2 {
        repeated float userVAR1 = 1;    // unique field id
        optional string userVAR2 = 2; // unique field id
        ...
    }

Users extend the base `Record` to include their one records.

    package singa;

    import "common.proto";  // required to import common.proto

    extend Record {
        optional UserRecord1 user_record1 = 101;  // unique extension field id, reserved for users (e.g., 101-200)
        optional UserRecord2 user_record1 = 102;  // unique extension field id, reserved for users (e.g., 101-200)
    }

The above code extends the SINGA `Record` with two user defined records.
Please refer to the
[Tutorial](https://developers.google.com/protocol-buffers/docs/reference/cpp-generated?hl=en#extension)
for extension of protocol messages.

{% comment %}
*Note*

There is an alternative way to define the proto extension.
In this way, you should be careful of the scope of fields and how to access the fields, which are different from the above.

    message UserRecord {
        extend Record {
            optional UserRecord user_record = 101;  // unique extension field id, reserved for users (e.g., 101-200)
        }
        repeated int userVAR1 = 1; // unique field id
        optional string userVAR2 = 2; // unique field id
        ...
    }
{% endcomment %}


### Shard creation

Users write code to convert their data into `Record`s and insert them into a shard.
Here are the steps,

1. Create a folder `USER_DATA` under `SINGA_ROOT`.


2. Prepare the source file, e.g., `create_shard.cc`,  in `SINGA_ROOT/USER_DATA`

        singa::DataShard myShard(outputpath, kCreate);
        // outputpath is the path of the folder for storing the shard

    the above code opens a folder for storing the data shard.

        singa::Record record;
        singa::UserRecord* myRecord = record.MutableExtension(singa::user_record);

    an user-defined record is allocated by the above code.


        myRecord->add_userVAR1( int_val );     // for repeated field
        myRecord->set_userVAR2( string_val );

    users load raw data and set/add them into user-defined record as shown above.


        // `String key`, will be a unique id for this message
        myShard.Insert( key, myRecord );

    Once the record is filled, it is inserted into the shard. If there are multiple
    data records, they should be inserted sequentially.
    After inserting all records, the shard is created.

3. Compile and link. Both *user.proto* and *create.cc* should be compiled and linked with libsinga.so.
  The following instruction generates *user.pb.cc* and *user.pb.h* from *user.proto*.

        protoc -I=SINGA_ROOT/USER_DATA --cpp_out=SINGA_ROOT/USER_DATA user.proto

    All code can be compiled and linked into an executable file

        g++ create_shard.cc user.pb.cc -std=c++11 -lsinga \
          -ISINGA_ROOT/include -LSINGA_ROOT/.libs/ -Wl,-unresolved-symbols=ignore-in-shared-libs \
          -Wl,-rpath=SINGA_ROOT/.libs/  -o create_shard.bin


4. Generate shard. Once the executable file is generated, users can run it to create data shard.

        ./create_shard.bin  <args>


### Example - CIFAR dataset
This example uses CIFAR-10 image dataset collected by [Alex Krizhevsky](http://www.cs.toronto.edu/~kriz/cifar.html).
The dataset consists of 60,000 32x32 colour images in 10 classes, with 6,000 images per class. There are 50,000 training images and 10,000 test images.
Each image has a label (stored as a number from 0 to 9). This dataset is stored in binary files.
SINGA has written the [create_shard.cc](https://github.com/apache/incubator-singa/blob/master/examples/cifar10/create_shard.cc)
to convert the images into `SingleLabelImageRecord`s and insert them into training and test shards.

1 Download raw data. The following command will download dataset in a folder `cifar-10-batches-bin`.

    $ cp Makefile.example Makefile   // an example makefile is provided
    $ make download

2 `SingleLabelImageRecord` is a built-in record provided by SINGA. We use it for images in CIFAR10.

        package singa;

        message Record {
          enum Type {
            kSingleLabelImage = 0;
          }
          optional Type type = 1 [default = kSingleLabelImage];
          optional SingleLabelImageRecord image = 2;   // for configuration
        }

        message SingleLabelImageRecord {
          repeated int32 shape = 1;                // it obtains 3 (rgb channels), 32 (row), 32 (col)
          optional int32 label = 2;                // label
          optional bytes pixel = 3;                // pixels
          repeated float data = 4 [packed = true]; // it is used for normalization
        }

2 Add/Set data into the record, and write it to shard.
  `create_shard.cc` will read CIFAR dataset and store necessary data in the record according to its definition.
  `add_VAR(.)` is used for repeated fields, and `set_VAR(.)` is used for optional fields.

        // for training
        DataShard train_shard("output_for_train", DataShard::kCreate);

        singa::Record record;
        singa::SingleLabelImageRecord* image = record.mutable_image();;
        image->add_shape(3);
        image->add_shape(32);
        image->add_shape(32);
        for (int fileid = 0; fileid < kCIFARTrainBatches; ++fileid) {
          for (int itemid = 0; itemid < kCIFARBatchSize; ++itemid) {
            read_image(&data_file, &label, str_buffer);
            image->set_label(label);
            image->set_pixel(str_buffer, kCIFARImageNBytes);
            int length = snprintf(str_buffer, kCIFARImageNBytes, "%05d", fileid * kCIFARBatchSize + itemid);
            train_shard.Insert(string(str_buffer, length), record);    // write a record to shard with unique ID
          }
        }

    Testing data is also stored in the same manner.
    In addition, it computes average values of image pixels in `image_mean.bin`, which will be used to normalize feature values.

        for (int itemid = 0; itemid < kCIFARBatchSize; ++itemid) {
          const string& pixels = image->pixel();
          for(int i=0; i<kCIFARImageNBytes; i++)
            mean.set_data(i, mean.data(i)+static_cast<uint8_t>(pixels[i]));
          count += 1;
        }
        for(int i=0; i<kCIFARImageNBytes; i++)
          mean.set_data(i, mean.data(i)/count);
        WriteProtoToBinaryFile(mean, (output_folder+"/image_mean.bin").c_str());

3 Create data shard for training and testing. SINGA provides a Makefile that contains instructions
  for compiling the source code and linking it with *libsinga.so*. Users just execute the following command.

    $ make create

  The shards for training and testing will be generated into *cifar10_train_shard* and *cifar10_test_shard* folders.


### Example - MNIST dataset
This example uses MNIST dataset of handwritten digits from [this page](http://yann.lecun.com/exdb/mnist/).
The database has a training set of 60,000 examples, and a test set of 10,000 examples.
Similar to the images of CIFAR10, each MNIST image has a single label. Hence, we still
use the built-in `SingleLabelImageRecord`. The process is almost the same as that for
the CIFAR10 dataset, except that the MNIST dataset is downloaded as binary files with
special format. SINGA has written the *create_shard.cc* to parse the binary files
and convert MNIST images into `SingleLabelImageRecord`s.

The following command will download the dataset

    $ cp Makefile.example Makefile   // an example makefile is provided
    $ make download

Data shard (e.g., `shard.data`) will be generated into folders, `mnist_train_shard` and `mnist_test_shard` by

    $ make create

## LMDB

To be filled soon.

## HDFS

To be filled soon.

