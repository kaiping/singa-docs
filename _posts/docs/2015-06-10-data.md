---
layout: post
title:  Data Preparation
category : docs
tags : [data]
---
{% include JB/setup %}

To submit a training job, users need to convert raw data (e.g., images, text documents) into records that can be recognized by SINGA. SINGA uses a DataLayer
to load these records into memory and uses ParserLayer to parse features (e.g., image pixels and labels) from these records. The records could be organized and
stored using many different ways, e.g., a file, a light database, or HDFS, as long as there is a corresponding DataLayer that can load the records.

### DataShard

To create shard for your own data, users may need to implement or modify the following files

- user.proto
- create_shard.cc
- Makefile

**1. Define record**

Record class is inherited from Message class whose format follows Google protocol buffers. Please refer to the [Tutorial][1].

Your record will be defined in a file, user.proto, as an extension of Record written in SINGA_ROOT/src/proto/common.proto.

(a) Declare the user-defined record as an extension of Record. Please refer to the [Tutorial][2] for Extension.

    package singa;

    import "common.proto";  // required to import common.proto

    extend Record {
        optional UserRecord1 user_record1 = 101;  // unique extension field id, reserved for users (e.g., 101-200)
        optional UserRecord2 user_record2 = 102;  // unique extension field id, reserved for users (e.g., 101-200)
    }

(b) Define the user own record

    message UserRecord1 {
        repeated int userVAR1 = 1;    // unique field id
        optional string userVAR2 = 2; // unique field id
        ...
    }

    message UserRecord2 {
        ...
    }

*Note*

There is an alternative way to define the proto extension.
In this way, you should be careful of the scope of fields and how to access the fields, which are different from the above.

    message UserRecord {
        extend Record {
            optional UserRecord user_record = 101;  // unique extension field id, reserved for users (e.g., 101-200)
        }
        repeated int userVAR1 = 1; // unique field id
        optional string userVAR2 = 2; // unique field id
        ...
    }

**2. Compile proto/Singa**

Once you defined protos, you need to compile them as follow.

    protoc -I=IMPORT_DIR --cpp_out=DST_DIR [proto1] [proto2] ...

    - IMPORT_DIR: path to contain proto files
    - DST_DIR: path to generate C++ codes (.pb.h and .pb.cc)

Assume that users will implement their own [Layers]() as well. The following commands help you to compile Singa sources as well as proto.

    $ cd SINGA_ROOT
    $ ./configure
    $ make

**3. Create shard**

(a) Create a folder for dataset and shard, e.g., we call it `USER_DATA`. (This folder would be the same as WORKSPACE.)

(b) Source files, e.g., `create_shard.cc`, will be in `SINGA_ROOT/USER_DATA`

DataShard object

    singa::DataShard myShard( outputpath, mode );

    - `string outputpath`, where user wants to create shard.
    - `int mode := kRead | kCreate | kAppend`, is defined in SINGA_ROOT/include/utils/data_shard.h

Record object

    singa::Record record;

    singa::UserRecord* myRecord = record.MutableExtension(singa::user_record);

    - `MutableExtension()` is templated method, generated after compile at Step 2 and processed at runtime.

(c) Set/Add values into your record

    myRecord->add_userVAR1( int_val );     // for repeated field
    myRecord->set_userVAR2( string_val );

(d) Write the record to shard

    myShard.Insert( key, myRecord );
- `String key`, will be a unique id for this message

**Note: Preparing Makefile**

There are some notes when you write your own Makefile

- Specify `outputpath` of output directory for shard.

- Make sure you copy `user.proto` into SINGA_ROOT/src/proto

Examples of creating shard can be found at [RNNLM]()


### Data Preparation for CNN, MLP, and RBM

## Example 1: CIFAR dataset

Example files can be found in `SINGA_ROOT/examples/cifar10`, which we assume to be WORKSPACE.

(a) Download raw data

This example uses CIFAR-10 image dataset collected by [Alex Krizhevsky](http://www.cs.toronto.edu/~kriz/cifar.html).
The dataset consists of 60,000 32x32 colour images in 10 classes, with 6,000 images per class. There are 50,000 training images and 10,000 test images.

The following command will download dataset in a folder `cifar-10-batches-bin`.

    $ cp Makefile.example Makefile   // an example makefile is provided
    $ make download

(b) Definition of record. Please refer to [Data Preparation]() for details.

Record message is defined in `common.proto`.
CIFAR example uses `SingleLableImageRecord`, also defined in `common.proto`, and one optional field is declared in Record message for its configuration as follows.

    package singa;

    message Record {
      enum Type {
        kSingleLabelImage = 0;
      }
      optional Type type = 1 [default = kSingleLabelImage];
      optional SingleLabelImageRecord image = 2;   // for configuration
    }

    message SingleLabelImageRecord {  
      repeated int32 shape = 1;                // it obtains 3 (rgb channels), 32 (row), 32 (col)
      optional int32 label = 2;                // label
      optional bytes pixel = 3;                // pixels
      repeated float data = 4 [packed = true]; // it is used for normalization
    }

(c) Add/Set data into the record, and write it to shard.

`create_shard.cc` will read CIFAR dataset and store necessary data in the record according to its definition.
`add_VAR(.)` is used for repeated fields, and `set_VAR(.)` is used for optional fields.

    // for training
    DataShard train_shard("output_for_train", DataShard::kCreate);

    singa::Record record;
    singa::SingleLabelImageRecord* image = record.mutable_image();;
    image->add_shape(3);
    image->add_shape(32);
    image->add_shape(32);
    for (int fileid = 0; fileid < kCIFARTrainBatches; ++fileid) {
      for (int itemid = 0; itemid < kCIFARBatchSize; ++itemid) {
        read_image(&data_file, &label, str_buffer);
        image->set_label(label);
        image->set_pixel(str_buffer, kCIFARImageNBytes);
        int length = snprintf(str_buffer, kCIFARImageNBytes, "%05d", fileid * kCIFARBatchSize + itemid);
        train_shard.Insert(string(str_buffer, length), record);    // write a record to shard with unique ID
      }
    }

Testing data is also stored in the same manner.
In addition, it computes average values of image pixels in `image_mean.bin`, which will be used to normalize feature values.

    for (int itemid = 0; itemid < kCIFARBatchSize; ++itemid) {
      const string& pixels = image->pixel();
      for(int i=0; i<kCIFARImageNBytes; i++)
        mean.set_data(i, mean.data(i)+static_cast<uint8_t>(pixels[i]));
      count += 1;
    }
    for(int i=0; i<kCIFARImageNBytes; i++)
      mean.set_data(i, mean.data(i)/count);
    WriteProtoToBinaryFile(mean, (output_folder+"/image_mean.bin").c_str());

(d) Create data shard for training and testing

Data shard (e.g., `shard.data`) will be generated into folders, `cifar10_train_shard` and `cifar10_test_shard` by

    $ make create


## Example 2: MNIST dataset

    Example files can be found in `SINGA_ROOT/examples/mnist`, which we assume to be WORKSPACE.

    (a) Download raw data

    This example uses MNIST database of handwritten digits from [this page](http://yann.lecun.com/exdb/mnist/).
    The database has a training set of 60,000 examples, and a test set of 10,000 examples.

    The following command will download `train-images-idx3-ubyte` (training set images), `train-labels-idx1-ubyte` (training set labels), `t10k-images-idx3-ubyte` (test set images), and `t10k-labels-idx1-ubyte` (test set labels).

        $ cp Makefile.example Makefile   // an example makefile is provided
        $ make download

    (b) Definition of record. Please refer to [Data Preparation]() for details.

    Record message is defined in `common.proto`.
    MNIST example uses `SingleLableImageRecord`, also defined in `common.proto`, and one optional field is declared in Record message for its configuration as follows.

        package singa;

        message Record {
          enum Type {
            kSingleLabelImage = 0;
          }
          optional Type type = 1 [default = kSingleLabelImage];
          optional SingleLabelImageRecord image = 2;   // for configuration
        }

        message SingleLabelImageRecord {  
          repeated int32 shape = 1;         // it obtains row and col
          optional int32 label = 2;         // label
          optional bytes pixel = 3;         // pixels
        }

    (c) Add/Set data into the record, and write it to shard.

    `create_shard.cc` will read MNIST dataset and store necessary data in the record according to its definition.
    `add_VAR(.)` is used for repeated fields, and `set_VAR(.)` is used for optional fields.

        DataShard shard(output, DataShard::kCreate);

        singa::Record record;
        singa::SingleLabelImageRecord* image = record.mutable_image();

        image->add_shape(rows);
        image->add_shape(cols);
        for (int item_id = 0; item_id < num_items; ++item_id) {
          image_file.read(pixels, rows * cols);   // load pixels of an image
          label_file.read(&label, 1);             // load label of the image
          image->set_pixel(pixels, rows * cols);  // set the pixel value
          image->set_label(label);                // set the label value
          shard.Insert(string(key), record);    // write a record to shard with unique ID
        }

    (d) Create data shard for training and testing

    Data shard (e.g., `shard.data`) will be generated into folders, `mnist_train_shard` and `mnist_test_shard` by

        $ make create

### LMDB

To be filled soon.

### HDFS

To be filled soon.

  [1]: https://developers.google.com/protocol-buffers/docs/cpptutorial
  [2]: https://developers.google.com/protocol-buffers/docs/reference/cpp-generated?hl=en#extension
